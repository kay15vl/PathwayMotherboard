---
title: Identifying Overlapping Gene Expression and Biological Processes Between
  Gestational Diabetes Mellitus and Postpartum Hemorrhageed
output: html_document
date: "2025-11-28"
geometry: margin=1in
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```



```{r}
# upload libraries
library(tidyverse)
library(data.table)
library(HGNChelper)
library(biomaRt) 
library(GEOquery)
library(RUVSeq) # may use depending on variation
library(DESeq2)
library(EDASeq)
library(EnhancedVolcano)
library(EnsDb.Hsapiens.v86) # used to convert transcript ids to gene ids
library(EnhancedVolcano)
library(clusterProfiler)
library(RColorBrewer)
library(org.Hs.eg.db)
```

# Step 1: Get Counts
## Get raw data and process
```{r}
# on imac
get_raw_data <- "/Users/karlavelalopez/Desktop/PathwayMotherboard/data/GSE203346_RAW"
get_files <- list.files(get_raw_data, pattern = "\\.tsv\\.gz$", full.names = TRUE)

```

```{r}
#check
length(get_files)
head(get_files)
```

```{r}
# get sample ids
sample_ids <- basename(get_files) |> str_extract("GSM\\d+")
length(sample_ids)
head(sample_ids)

```


```{r}
# label files with their sample id
names(get_files) <- sample_ids
head(get_files)
```


```{r}
# create transcript ids to gene ids mapping
transcript_maps <- transcripts(EnsDb.Hsapiens.v86,
                            columns = c("tx_id", "tx_version", "gene_id", "gene_name")) %>% 
  as.data.frame()
head(transcript_maps)
```


```{r}
map_to_genes <- transcript_maps %>% 
  dplyr::select(tx_id,gene_id)
head(map_to_genes)
```

```{r}
# take a look at one of the tsv.gz files
check_file <- "/Users/karlavelalopez/Desktop/PathwayMotherboard/data/GSE203346_RAW/GSM6167352_17A020341F_S30_L004.tsv.gz"
check<- read_tsv(gzfile(check_file), n_max =20)
head(check)
```


```{r}
# get raw counts matrix
first_entry <- fread(get_files[1])

# save transcript IDs
transcript_ids <-first_entry$target_id

# initialize empty matrix
counts_matrix <- matrix(
  NA_real_,
  nrow= length(transcript_ids), # one row for each transcript
  ncol = length(get_files) # one column per sample
)

# set rownames and column names
rownames(counts_matrix) <- transcript_ids
colnames(counts_matrix) <- sample_ids

# fill the matrix with each transcript's respective count from the est_counts column
for(i in seq_along(get_files)){
  # read file
  dt <- fread(get_files[i])
  
  # make sure the order of each data file matches the first read data file
  idx <- match(transcript_ids, dt$target_id)
  
  # get the counts form est_counts column in the correct order
  counts_idx <- dt$est_counts[idx]
  
  # store in the correct location
  counts_matrix[,i] <- counts_idx
}

# since my transcript to gene mapping does not have decimals, need to get rid of 
# the integer after the (.) in the transcript id
tx_ids <- sub("\\..*$", "", rownames(counts_matrix))  # transcript ids from the counts matrix

# make a vector with the transcript and gene mappings
tx_to_gene <- setNames(map_to_genes$gene_id, map_to_genes$tx_id)

# map gene ids to our counts matrix
gene_ids <- tx_to_gene[tx_ids]

# check to see how many transcript ids do not have a corresponding gene id from 
# the mapping df
sum(is.na(gene_ids))
```

```{r}
# keep track of which transcripts did not map
keep_transcripts <- !is.na(gene_ids)

# filter out unmapped transcripts from counts matrix
keep_counts <- counts_matrix[keep_transcripts,]

# save the genes that were kept
kept_genes <- gene_ids[keep_transcripts]

# collapse the transcript counts to gene level counts. Will sum coutns based
# on the genes that had mappings
gene_counts <- rowsum(
  x = keep_counts,
  group = kept_genes
)

# check dimensions of new counts matrix and look at data
dim(gene_counts)
head(gene_counts,5)

# for easier data handling, rounding up to whole numbers
gene_counts <- round(gene_counts)

# save this counts table 
saveRDS(gene_counts, file = "../data/processed_counts.rds")
```

#### Lodad processed counts matrix
```{r}
loaded_gene_counts <- readRDS("../data/processed_counts.rds")
```


# Step 2: Build Metadata

```{r}
# get series matrix 
gse_list <- getGEO("GSE203346", GSEMatrix = TRUE)

```

```{r}
# get the expression set object
first_gse <- gse_list[[1]]

# get metadata/phenotype
pheno <- pData(first_gse)

# check data
colnames(pheno)
head(pheno,1)
```

```{r}
# ensure we are finding the correct tissue type and group labels
unique(pheno$characteristics_ch1) # should have GDM and control labels
unique(pheno$source_name_ch1) # should say placenta and umbilical cord
```

```{r}
clean_metadata <- pheno %>% 
  # create column that has appropriate and matching conditions for each acession number
  mutate(
    sample_id = geo_accession,
    condition = case_when(
      str_detect(characteristics_ch1, "GDM") ~ "GDM",
      str_detect(characteristics_ch1, "Control") ~ "Control",
      TRUE ~ NA_character_
    ),
    
    # create column that has appropriate and matching sample tissue type for each acession number
    tissue = case_when(
      str_detect(source_name_ch1, regex("umbilical", ignore_case = TRUE)) ~ "Cord",
      str_detect(source_name_ch1, regex("placenta", ignore_case = TRUE)) ~ "Placenta",
      TRUE ~ NA_character_  # anything else becomes NA
    )) %>% 
  
    # keep important columns
  dplyr::select(sample_id, tissue, condition, everything())

  
```


```{r}
# line up the metadata with the counts matrix
gene_counts <- loaded_gene_counts

# make sure the column names are the GSM ids
colnames(gene_counts) <- str_extract(colnames(gene_counts), "GSM\\d+")

# find overlap between samples (GSM ids) in the counts matrix and metadata. 
# want to keep that are only seen in both metadata and counts matrix.
same_samples <- intersect(colnames(gene_counts), clean_metadata$sample_id)

# subset the counts matrix to the samples found to be shared between metadata and counts matrix
same_genecounts <- gene_counts[, same_samples]

# then subset metadata by the samples
same_metadata <- clean_metadata %>% 
  dplyr::filter(sample_id %in% same_samples)

# reorder metadata rows so they match the column order of the counts matrix
same_metadata <- same_metadata[match(same_samples, same_metadata$sample_id),]

# check output; metadata and counts matrix should have the same GSM ids/samples
# and in the same order
all(colnames(same_genecounts)== same_metadata$sample_id)

# redefine the counts matrix and metadata with the new ordered data
gene_counts <- same_genecounts
clean_metadata <- same_metadata
```

# Step 3: QC
```{r}
# get gene level metadata from ENsDB
ensg_data <- genes(EnsDb.Hsapiens.v86, 
                   columns = c("gene_id", "gene_name", "gc_content", "gene_length")) %>% 
  as.data.frame()

# only get the gc content and gene length for our counts data
keep_ensg <- ensg_data %>% dplyr::filter(gene_id %in% rownames(gene_counts))

# match row order of keep_ensg to  counts matrix
keep_ensg <- keep_ensg[match(rownames(gene_counts), keep_ensg$gene_id), ]

# create the seqexpression object
eda_obj <- newSeqExpressionSet(
  counts = as.matrix(gene_counts),
  featureData = AnnotatedDataFrame(keep_ensg),
  phenoData = AnnotatedDataFrame(clean_metadata)
  
)

# order samples by condition
order_cond <- order(pData(eda_obj)$condition)
reorder_edaobj <- eda_obj[, order_cond]

# set up labels for conditions for each sample
cond <- pData(reorder_edaobj)$condition

# set colors
cond_colors <- ifelse(cond == "GDM", "gold", "steelblue")


reorder_edaobj
```
## Boxplots for raw gene counts

```{r}
# set margins

par(mar= c(12,5,4,15), xpd = TRUE)

EDASeq::boxplot(log10(counts(reorder_edaobj)+1), 
                col = cond_colors,
                las = 2,
                cex.axis = 0.9,
                cex.names = 0.9,
                main = "Raw gene counts by sample (log)",
                ylab = "log10 (count +1)",
                xlab = "")
mtext("Samples", side = 1, line = 7, cex = 0.9)
legend("topright", 
       inset = c(-0.3, 0.1),
       legend = c("Control", "GDM"),
       fill = c("steelblue", "gold"),
       bty = "n")
```

## Boxplots for raw gene counts split up by sample
```{r}
#plot by tissue
tissue <- pData(reorder_edaobj)$tissue
cond <- pData(reorder_edaobj)$condition

# get index for placenta samples
idx_placenta <- tissue == "Placenta"
cond_placenta <- cond[idx_placenta]
cond_color_placenta <- ifelse(cond_placenta=="GDM", "gold", "steelblue")

par(mar= c(12,5,4,15), xpd = TRUE)

EDASeq::boxplot(log10(counts(reorder_edaobj[, idx_placenta]) + 1), 
                isLog= TRUE,
                col = cond_color_placenta,
                las = 2,
                cex.axis = 0.9,
                cex.names = 0.9,
                main = "Raw gene counts for Placental Samples (log)",
                ylab = "log10 (count +1)",
                xlab = "")

idx_cord <- tissue == "Cord"
cond_cord <- cond[idx_cord]
cond_color_cord <- ifelse(cond_cord=="GDM", "gold", "steelblue")

par(mar= c(12,5,4,15), xpd = TRUE)
EDASeq::boxplot(log10(counts(reorder_edaobj[, idx_cord]) + 1), 
                isLog= TRUE,
                col = cond_color_cord,
                las = 2,
                cex.axis = 0.9,
                cex.names = 0.9,
                main = "Raw gene counts for Umbilical Cord Samples (log)",
                ylab = "log10 (count +1)",
                xlab = "")

```

## Mean Variance Plot

```{r}
# plot Mean Variance plot
meanVarPlot(eda_obj, log=TRUE)
```

```{r}
# check to see if we have gc content and length in eda object
colnames(featureData(eda_obj))
```

### Didn't have these columns so need to add them to the object to do bias plots to see if gc and length are responsible for the technical variance seen in the raw gene counts and mean variance plot
```{r}
# get the gene ids in the eda object
ids <- fData(eda_obj)$gene_id

# get length and gc content from hsa
#length_gc <- getGeneLengthAndGCContent(ids, org = "hsa", mode = "biomart")

# getGeneLengthAndGCContent takes forever to run so save the length_gc as a rds
#saveRDS(length_gc, file = "../data/length_gc_human_data.rds")
length_gc <- readRDS("../data/length_gc_human_data.rds")

#add to object
fData(eda_obj)$length <- length_gc[, "length"]
fData(eda_obj)$gc <- length_gc[, "gc"]

# check gc and length mappings
cat("For GC mapping.")
str(fData(eda_obj)$gc)
summary(fData(eda_obj)$gc)
table(is.na(fData(eda_obj)$gc))

cat("For length mapping.")
str(fData(eda_obj)$length)
summary(fData(eda_obj)$length)
table(is.na(fData(eda_obj)$length))

# we have some NAs so we have to get rid of these before plotting
nagc_edj_obj <- !is.na(fData(eda_obj)$gc)
final_edj_obj <- eda_obj[nagc_edj_obj, ]

naleng_edj_obj <- !is.na(fData(eda_obj)$length)
final_edj_obj <- eda_obj[naleng_edj_obj, ]

# set up colors for condition
cond <- factor(pData(final_edj_obj)$condition, levels = c("Control", "GDM"))
base_colors <- c("blue", "red")
colors_cond<- base_colors[cond]
```

## Bias plots

```{r}
# plot biasPlots
#par(mar= c(5,5,3,6), xpd = FALSE)
biasPlot(final_edj_obj, 
         "gc", 
         ylog=TRUE, 
         ylim = c(0,12),
         xlim = c(0.18,0.9),
         col= colors_cond,
         main = "GC content bias before normalization",
         xlab = "GC Content",
         ylab = "Log Gene Counts")

legend("topleft", 
       #inset = c(-0.3, 0.1),
       legend = c("Control", "GDM"),
       fill = base_colors,
       bty = "n")

```

```{r}
# need to fix the scale for length due to gene lengths varying. 
# look at window where 99% of the gene lengths lie
length_scale <- quantile(fData(final_edj_obj)$length, probs = c(0.01,0.99), na.rm=TRUE)

#plot
biasPlot(final_edj_obj, 
         "length", 
         ylog=TRUE,
         # ylim = c(0,12),
         xlim = c(length_scale[1], length_scale[2]),
         col= colors_cond,
         main = "Length bias before normalization",
         xlab = "Gene Length (bp)",
         ylab = "Log Gene Counts")

legend("topleft", 
       legend = c("Control", "GDM"),
       fill = base_colors,
       bty = "n")
```

### There is length and gc content bias. Need to normalize.

```{r}
# do within lane normalizaiton to handle these two biases
norm_eda_obj <- withinLaneNormalization(final_edj_obj,"gc", which= "full")
norm_all_eda_obj <- withinLaneNormalization(norm_eda_obj, "length", which = "full")
```


```{r}
# adjust scale because GC content range and gene counts can vary greatly due to human genes being very different sizes; they read extremes
gc_range <- quantile(fData(final_edj_obj)$gc, c(0.01,0.99))
#replot to see impact of normalization
biasPlot(norm_all_eda_obj, 
         "gc", 
         ylog=TRUE, 
         ylim = c(0,200),
         xlim = gc_range,
         col= colors_cond,
         main = "GC content bias after normalization",
         xlab = "GC Content",
         ylab = "Log Gene Counts")

legend("topleft", 
       #inset = c(-0.3, 0.1),
       legend = c("Control", "GDM"),
       fill = base_colors,
       bty = "n")
```

```{r}
len_range <- quantile(fData(final_edj_obj)$length, c(0.01,0.99))
#plot
biasPlot(norm_all_eda_obj, 
         "length", 
         ylog=TRUE,
         ylim = c(0,180),
         xlim = len_range,
         col= colors_cond,
         main = "Length bias after normalization",
         xlab = "Gene Length (bp)",
         ylab = "Log Gene Counts")

legend("topleft", 
       legend = c("Control", "GDM"),
       fill = base_colors,
       bty = "n")
```

```{r}
# plot Mean Variance plot
# plot Mean Variance plot
par(mfrow=c(1,2))
meanVarPlot(eda_obj, log=TRUE, main ="Mean Variance Plot Before Normalization")
meanVarPlot(norm_all_eda_obj, log=TRUE, main ="Mean Variance Plot After Normalization")
```

## Now to correct bias between lanes to correct for different library sizes and sequencing depths
```{r}
norm_btwln_eda_obj <- betweenLaneNormalization(
  norm_all_eda_obj,
  which = "median"
)
```


```{r}

# reorder based on condition
cond <- factor(pData(final_edj_obj)$condition,
               levels = c("Control", "GDM"))
ord <- order(cond)         

# reorder raw and normalized eda objects
raw_eda_ord  <- final_edj_obj[, ord]
norm_eda_ord <- norm_btwln_eda_obj[, ord]

# colors for each sample in this new order
cond_ord    <- cond[ord]
cond_colors <- ifelse(cond_ord == "Control", "blue", "red")

#par(mfrow = c(1, 2), mar = c(12,5,4,10), xpd = TRUE)

# before normalization
EDASeq::boxplot(
  log10(counts(raw_eda_ord) + 1),
  col       = cond_colors,
  las       = 2,
  cex.axis  = 0.9,
  cex.names = 0.9,
  main      = "Raw gene counts by sample before Normalization (log)",
  ylab      = "log10(count + 1)",
  xlab      = ""
)
mtext("Samples (Control → GDM)", side = 1, line = 9, cex = 0.9)
legend("topright",
       inset  = c(-0.3, 0.1),
       legend = c("Control", "GDM"),
       fill   = c("blue", "red"),
       bty    = "n")

# after normalization
EDASeq::boxplot(
  log10(counts(norm_eda_ord) + 1),
  col       = cond_colors,  
  las       = 2,
  cex.axis  = 0.9,
  cex.names = 0.9,
  main      = "Gene counts after normalization (log)",
  ylab      = "log10(count + 1)",
  xlab      = ""
)
mtext("Samples (Control → GDM)", side = 1, line = 9, cex = 0.9)
legend("topright",
       inset  = c(-0.3, 0.1),
       legend = c("Control", "GDM"),
       fill   = c("blue", "red"),
       bty    = "n")

par(mfrow = c(1,1), xpd = FALSE)

```







# Step 4: DESeq2 Setup
```{r}
# since I want to look at tissue specific DE, I need to separate them
# placenta samples
placenta_samples <- clean_metadata$sample_id[clean_metadata$tissue == "Placenta"]

# cord samples
cord_samples <- clean_metadata$sample_id[clean_metadata$tissue == "Cord"]

# get the counts for each tissue type 
placenta_counts <- gene_counts[, placenta_samples]
cord_counts <- gene_counts[, cord_samples]

# get the metadata
placenta_metadata<- clean_metadata[clean_metadata$sample_id %in% placenta_samples,]
cord_metadata <- clean_metadata[clean_metadata$sample_id %in% cord_samples,]

# check to make sure we have the correct subsets
all(colnames(placenta_counts) == placenta_metadata$sample_id)
all(colnames(cord_counts) == cord_metadata$sample_id)
```

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
```{r}
# create the DESeq objects for DESeq
dds_placenta <- DESeqDataSetFromMatrix(
  countData = placenta_counts,
  colData = placenta_metadata,
  design = ~ condition
)

dds_cord <- DESeqDataSetFromMatrix(
  countData = cord_counts,
  colData = cord_metadata,
  design = ~ condition
)

# filter out low expressed genes
# keep genes with 10 or more genes in 3 or more samples
keep_placenta <- rowSums(counts(dds_placenta) >= 10) >=3
keep_cord <- rowSums(counts(dds_cord) >= 10) >=3

# filter out the low genes
dds_placenta <- dds_placenta[keep_placenta, ]
dds_cord <- dds_cord[keep_cord, ]

# Run DESeq2
dds_placenta <- DESeq(dds_placenta)
dds_cord <- DESeq(dds_cord)

# do dispersion plots to confirm that DESeq2 is the best model to use for our type of data
plotDispEsts(dds_placenta, main = "Dispersion estimates for Placental Samples (GDM vs Control)")
plotDispEsts(dds_cord, main = "Dispersion estimates for Umbilical Cord \nBlood Samples (GDM vs Control)")
```


```{r}
# do variance-stabalizing transformation 
vsd_placenta <- vst(dds_placenta, blind = FALSE)
vsd_cord <- vst(dds_cord, blind = FALSE)

# pca plots
plotPCA (vsd_placenta, intgroup = "condition") +
  ggtitle("Placenta PCA: GDM vs Control")
plotPCA (vsd_cord, intgroup = "condition") +
  ggtitle("Umbilical Cord Blood PCA: GDM vs Control")
```

### PCA plots show that condition accounts for some of the variance observed in gene expression, particularly in the placenta samples. In contrast, very little condition-related variation is evident in the cord blood samples. Although the placenta samples do not form completely distinct clusters, there is a some separation between GDM and control along PC1. This is expected because many other biological and technical covariates contribute to the remaining variance. The slight but noticeable separation suggests that there are detectable transcriptomic differences between conditions in the placenta

```{r}
# separate results by condition for each tissue
results_placenta <- results(dds_placenta, contrast = c("condition", "GDM", "Control"))
results_cord <- results(dds_cord, contrast = c("condition", "GDM", "Control"))

# order by adjusted p-value
results_placenta <- results_placenta[order(results_placenta$padj), ]
results_cord <- results_cord[order(results_cord$padj), ]

head(results_placenta)
head(results_cord)
```

# Step 5: Differential Expression Results
```{r}
head(results_placenta, 20)
head(results_cord, 20)
```


```{r}
# count significant genes with p threshold of <0.05
sum(results_placenta$padj < 0.05, na.rm = TRUE)
sum(results_cord$padj < 0.05, na.rm = TRUE)


```

```{r}
# MA Plots
plotMA(results_placenta, ylim=c(-6,6), main ="Placenta: GDM vs Control")
plotMA(results_cord, ylim=c(-6,6), main= "Umbilical Cord: GDM vs Control")
```


```{r}
EnhancedVolcano(
  as.data.frame(results_placenta),
  lab = rownames(results_placenta),
  x = "log2FoldChange",
  y = "pvalue",
  title = "Placenta: GDM vs Control",
  axisLabSize = 10,
  pCutoff = 0.05,
  FCcutoff = 1,
  pointSize = 1,
  labSize = 2.0,
  col = c("grey30", "forestgreen", "royalblue", "red2"),
  legendPosition = "right",
  legendLabSize = 10,
  legendIconSize = 3,
  caption = NULL
)
```



#Step 6: GDM and PPH Gene overlaps
```{r}
# get pph related genes. 
# starting with the proteins to map the genes 
pph_prot <- read_lines("../data/pph_proteinlist.txt")

# get rid of empty lines and duplicates
pph_prot <- unique(pph_prot[pph_prot != ""])

head(pph_prot)
length(pph_prot)
```


```{r}
# clean protein names
prot_clean <- str_trim(pph_prot)
prot_clean <- str_to_upper(prot_clean)

# get protein to mapping info
get_gene_info <- checkGeneSymbols(prot_clean, species = "human")
protein_to_gene <- get_gene_info$Suggested.Symbol

# keep only unique genes and leave out nas
protein_to_gene <- unique(protein_to_gene[!is.na(protein_to_gene)])

# there are some results that had multiple mappings, split these into their own row
protein_split <- str_split(protein_to_gene, pattern = "///")
protein_split <- lapply(protein_split, str_trim)

# convert into a vector and get rid of NA results
protein_to_gene <- unique(unlist(protein_split))
protein_to_gene <- protein_to_gene[protein_to_gene !=""]

protein_to_gene

```

```{r}
# get gene list
pph_genes <- read_lines("../data/pph_genelist.txt")

#  clean list
pph_genes <- str_trim(pph_genes[pph_genes!=""])

# combine 
pph_gene_symbols <- c(protein_to_gene, pph_genes)

# ensure format of gene symbols is the same for all genes in list
pph_gene_symbols <- str_to_upper(str_trim(pph_gene_symbols))

# get rid of duplicates
pph_gene_symbols <- unique(pph_gene_symbols)

pph_gene_symbols
length(pph_gene_symbols)
```


```{r}
# map ensembl to gene symbols since DE analysis of placenta is in ensembl
pph_map_ensembl <- bitr(
  pph_gene_symbols,
  fromType ="SYMBOL",
  toType = c("ENSEMBL", "ENTREZID"),
  OrgDb = org.Hs.eg.db
)

head(pph_map_ensembl)
nrow(pph_map_ensembl)
```


```{r}
#get rid of NAs
pph_map_ensembl <- pph_map_ensembl[!is.na(pph_map_ensembl$ENTREZID) & !is.na(pph_map_ensembl$SYMBOL), ]

# get rid of redundant genes
pph_symbols_final <- unique(pph_map_ensembl$SYMBOL)
pph_ensembl_final <- unique(pph_map_ensembl$ENSEMBL)
pph_entrez_final  <- unique(pph_map_ensembl$ENTREZID)

length(pph_symbols_final)
length(pph_entrez_final)
```


```{r}
# get de results for the placenta samples
res_pl <- as.data.frame(results_placenta)

# keep only rows padj < 0.05 and leave any na out
res_pl_sig <- subset(res_pl, !is.na(padj) & padj < 0.05)

nrow(res_pl_sig)
head(res_pl_sig)

# add gene ids
res_pl_sig$gene_id <- rownames(res_pl_sig)
head(res_pl_sig)

# add entrez id and symbols
pl_map_genes <- bitr(
  res_pl_sig$gene_id,
  fromType = "ENSEMBL", 
  toType = c("SYMBOL", "ENTREZID"),
  OrgDb = org.Hs.eg.db
)

# drop the NAs
pl_map_genes <- pl_map_genes[!is.na(pl_map_genes$SYMBOL) & !is.na(pl_map_genes$ENTREZID), ]

# take out redundant mappings
pl_symbols <- unique(pl_map_genes$SYMBOL)
pl_entrez <- unique(pl_map_genes$ENTREZID)
```


## Take a look at what genes overlap between the Placental GDM genes and the PPH genes
```{r}
# how many genes are shared between pph and gdm
pph_gdm_overlap <- intersect(pph_entrez_final, pl_entrez)

# whats seen only in pph
pph_only <- setdiff(pph_entrez_final, pl_entrez)

# whats seen only in GDM
gdm_only_pl <- setdiff(pl_entrez, pph_entrez_final)

# all of the pph genes
length(pph_entrez_final)   

# DE GDM genes in placenta tissues
length(pl_entrez)      

# total shared between GDM and pph
length(pph_gdm_overlap)     

```
### No gene overlaps :(

```{r}
# create gene lists to run on Pygeneplexus
write.table(pph_entrez_final,
            file = "../results/PPH_genes_for_pygeneplexus.txt",
            quote = FALSE, row.names = FALSE, col.names = FALSE)


write.table(pl_entrez,
            file = "../results/GDM_placenta_genes_for_pygeneplexus.txt",
            quote = FALSE, row.names = FALSE, col.names = FALSE)

```



# Step 7: Run PyGenePlexus on web app
https://geneplexus.net/
- Did new analysis and did an analysis for each gene set (pph genes and GDM placental genes)
- Used BioGRID for network due to it being more rigoursly validataed interactions 
- 86/92 genes are in BioGRID for the GDM gene set
- 50/50 genes are in BioGRID for the PPH gene set
- geneset context combined





