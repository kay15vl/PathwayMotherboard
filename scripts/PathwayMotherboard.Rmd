---
title: Identifying Overlapping Gene Expression and Biological Processes Between
  Gestational Diabetes Mellitus and Postpartum Hemorrhageed
output: html_document
date: "2025-11-28"
geometry: margin=1in
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```



```{r}
# upload libraries
library(tidyverse)
library(data.table)
library(biomaRt)
library(GEOquery)
library(RUVSeq) # may use depending on variation
library(DESeq2)
library(EDASeq)
library(EnhancedVolcano)
library(EnsDb.Hsapiens.v86) # used to convert transcript ids to gene ids
library(EnhancedVolcano)
library(clusterProfiler)
library(RColorBrewer)
library(org.Hs.eg.db)
```

# Step 1: Get Counts
## Get raw data and process
```{r}
# on imac
get_raw_data <- "/Users/karlavelalopez/Desktop/PathwayMotherboard/data/GSE203346_RAW"
get_files <- list.files(get_raw_data, pattern = "\\.tsv\\.gz$", full.names = TRUE)

```

```{r}
#check
length(get_files)
head(get_files)
```

```{r}
# get sample ids
sample_ids <- basename(get_files) |> str_extract("GSM\\d+")
length(sample_ids)
head(sample_ids)

```


```{r}
# label files with their sample id
names(get_files) <- sample_ids
head(get_files)
```


```{r}
# create transcript ids to gene ids mapping
transcript_maps <- transcripts(EnsDb.Hsapiens.v86,
                            columns = c("tx_id", "tx_version", "gene_id", "gene_name")) %>% 
  as.data.frame()
head(transcript_maps)
```


```{r}
map_to_genes <- transcript_maps %>% 
  dplyr::select(tx_id,gene_id)
head(map_to_genes)
```

```{r}
# take a look at one of the tsv.gz files
check_file <- "/Users/karlavelalopez/Desktop/PathwayMotherboard/data/GSE203346_RAW/GSM6167352_17A020341F_S30_L004.tsv.gz"
check<- read_tsv(gzfile(check_file), n_max =20)
head(check)
```


```{r}
# get raw counts matrix
first_entry <- fread(get_files[1])

# save transcript IDs
transcript_ids <-first_entry$target_id

# initialize empty matrix
counts_matrix <- matrix(
  NA_real_,
  nrow= length(transcript_ids), # one row for each transcript
  ncol = length(get_files) # one column per sample
)

# set rownames and column names
rownames(counts_matrix) <- transcript_ids
colnames(counts_matrix) <- sample_ids

# fill the matrix with each transcript's respective count from the est_counts column
for(i in seq_along(get_files)){
  # read file
  dt <- fread(get_files[i])
  
  # make sure the order of each data file matches the first read data file
  idx <- match(transcript_ids, dt$target_id)
  
  # get the counts form est_counts column in the correct order
  counts_idx <- dt$est_counts[idx]
  
  # store in the correct location
  counts_matrix[,i] <- counts_idx
}

# since my transcript to gene mapping does not have decimals, need to get rid of 
# the integer after the (.) in the transcript id
tx_ids <- sub("\\..*$", "", rownames(counts_matrix))  # transcript ids from the counts matrix

# make a vector with the transcript and gene mappings
tx_to_gene <- setNames(map_to_genes$gene_id, map_to_genes$tx_id)

# map gene ids to our counts matrix
gene_ids <- tx_to_gene[tx_ids]

# check to see how many transcript ids do not have a corresponding gene id from 
# the mapping df
sum(is.na(gene_ids))
```

```{r}
# keep track of which transcripts did not map
keep_transcripts <- !is.na(gene_ids)

# filter out unmapped transcripts from counts matrix
keep_counts <- counts_matrix[keep_transcripts,]

# save the genes that were kept
kept_genes <- gene_ids[keep_transcripts]

# collapse the transcript counts to gene level counts. Will sum coutns based
# on the genes that had mappings
gene_counts <- rowsum(
  x = keep_counts,
  group = kept_genes
)

# check dimensions of new counts matrix and look at data
dim(gene_counts)
head(gene_counts,5)

# for easier data handling, rounding up to whole numbers
gene_counts <- round(gene_counts)

# save this counts table 
saveRDS(gene_counts, file = "../data/processed_counts.rds")
```

#### Lodad processed counts matrix
```{r}
loaded_gene_counts <- readRDS("../data/processed_counts.rds")
```


# Step 2: Build Metadata

```{r}
# get series matrix 
gse_list <- getGEO("GSE203346", GSEMatrix = TRUE)

```

```{r}
# get the expression set object
first_gse <- gse_list[[1]]

# get metadata/phenotype
pheno <- pData(first_gse)

# check data
colnames(pheno)
head(pheno,1)
```

```{r}
# ensure we are finding the correct tissue type and group labels
unique(pheno$characteristics_ch1) # should have GDM and control labels
unique(pheno$source_name_ch1) # should say placenta and umbilical cord
```

```{r}
clean_metadata <- pheno %>% 
  # create column that has appropriate and matching conditions for each acession number
  mutate(
    sample_id = geo_accession,
    condition = case_when(
      str_detect(characteristics_ch1, "GDM") ~ "GDM",
      str_detect(characteristics_ch1, "Control") ~ "Control",
      TRUE ~ NA_character_
    ),
    
    # create column that has appropriate and matching sample tissue type for each acession number
    tissue = case_when(
      str_detect(source_name_ch1, regex("umbilical", ignore_case = TRUE)) ~ "Cord",
      str_detect(source_name_ch1, regex("placenta", ignore_case = TRUE)) ~ "Placenta",
      TRUE ~ NA_character_  # anything else becomes NA
    )) %>% 
  
    # keep important columns
  dplyr::select(sample_id, tissue, condition, everything())

  
```


```{r}
# line up the metadata with the counts matrix
gene_counts <- loaded_gene_counts

# make sure the column names are the GSM ids
colnames(gene_counts) <- str_extract(colnames(gene_counts), "GSM\\d+")

# find overlap between samples (GSM ids) in the counts matrix and metadata. 
# want to keep that are only seen in both metadata and counts matrix.
same_samples <- intersect(colnames(gene_counts), clean_metadata$sample_id)

# subset the counts matrix to the samples found to be shared between metadata and counts matrix
same_genecounts <- gene_counts[, same_samples]

# then subset metadata by the samples
same_metadata <- clean_metadata %>% 
  dplyr::filter(sample_id %in% same_samples)

# reorder metadata rows so they match the column order of the counts matrix
same_metadata <- same_metadata[match(same_samples, same_metadata$sample_id),]

# check output; metadata and counts matrix should have the same GSM ids/samples
# and in the same order
all(colnames(same_genecounts)== same_metadata$sample_id)

# redefine the counts matrix and metadata with the new ordered data
gene_counts <- same_genecounts
clean_metadata <- same_metadata
```

# Step 3: QC
```{r}
# get gene level metadata from ENsDB
ensg_data <- genes(EnsDb.Hsapiens.v86, 
                   columns = c("gene_id", "gene_name", "gc_content", "gene_length")) %>% 
  as.data.frame()

# only get the gc content and gene length for our counts data
keep_ensg <- ensg_data %>% dplyr::filter(gene_id %in% rownames(gene_counts))

# match row order of keep_ensg to  counts matrix
keep_ensg <- keep_ensg[match(rownames(gene_counts), keep_ensg$gene_id), ]

# create the seqexpression object
eda_obj <- newSeqExpressionSet(
  counts = as.matrix(gene_counts),
  featureData = AnnotatedDataFrame(keep_ensg),
  phenoData = AnnotatedDataFrame(clean_metadata)
  
)

# order samples by condition
order_cond <- order(pData(eda_obj)$condition)
reorder_edaobj <- eda_obj[, order_cond]

# set up labels for conditions for each sample
cond <- pData(reorder_edaobj)$condition

# set colors
cond_colors <- ifelse(cond == "GDM", "gold", "steelblue")


reorder_edaobj
```

```{r}
# set margins

par(mar= c(12,5,4,15), xpd = TRUE)

EDASeq::boxplot(log10(counts(reorder_edaobj)+1), 
                col = cond_colors,
                las = 2,
                cex.axis = 0.9,
                cex.names = 0.9,
                main = "Raw gene counts by sample (log)",
                ylab = "log10 (count +1)",
                xlab = "")
mtext("Samples", side = 1, line = 7, cex = 0.9)
legend("topright", 
       inset = c(-0.3, 0.1),
       legend = c("Control", "GDM"),
       fill = c("steelblue", "gold"),
       bty = "n")
```


```{r}
#plot by tissue
tissue <- pData(reorder_edaobj)$tissue
cond <- pData(reorder_edaobj)$condition

# get index for placenta samples
idx_placenta <- tissue == "Placenta"
cond_placenta <- cond[idx_placenta]
cond_color_placenta <- ifelse(cond_placenta=="GDM", "gold", "steelblue")

par(mar= c(12,5,4,15), xpd = TRUE)

EDASeq::boxplot(log10(counts(reorder_edaobj[, idx_placenta]) + 1), 
                isLog= TRUE,
                col = cond_color_placenta,
                las = 2,
                cex.axis = 0.9,
                cex.names = 0.9,
                main = "Raw gene counts for Placental Samples (log)",
                ylab = "log10 (count +1)",
                xlab = "")

idx_cord <- tissue == "Cord"
cond_cord <- cond[idx_cord]
cond_color_cord <- ifelse(cond_cord=="GDM", "gold", "steelblue")

par(mar= c(12,5,4,15), xpd = TRUE)
EDASeq::boxplot(log10(counts(reorder_edaobj[, idx_cord]) + 1), 
                isLog= TRUE,
                col = cond_color_cord,
                las = 2,
                cex.axis = 0.9,
                cex.names = 0.9,
                main = "Raw gene counts for Umbilical Cord Samples (log)",
                ylab = "log10 (count +1)",
                xlab = "")

```


```{r}
# plot Mean Variance plot
meanVarPlot(eda_obj, log=TRUE)
```

```{r}
# check to see if we have gc content and length in eda object
colnames(featureData(eda_obj))
```

### Didn't have these columns so need to add them to the object to do bias plots to see if gc and length are responsible for the technical variance seen in the raw gene counts and mean variance plot
```{r}
# get the gene ids in the eda object
ids <- fData(eda_obj)$gene_id

# get length and gc content from hsa
#length_gc <- getGeneLengthAndGCContent(ids, org = "hsa", mode = "biomart")

# getGeneLengthAndGCContent takes forever to run so save the length_gc as a rds
#saveRDS(length_gc, file = "../data/length_gc_human_data.rds")
length_gc <- readRDS("../data/length_gc_human_data.rds")

#add to object
fData(eda_obj)$length <- length_gc[, "length"]
fData(eda_obj)$gc <- length_gc[, "gc"]

```




# Step 4: DESeq2 Setup
```{r}
# since I want to look at tissue specific DE, I need to separate them
# placenta samples
placenta_samples <- clean_metadata$sample_id[clean_metadata$tissue == "Placenta"]

# cord samples
cord_samples <- clean_metadata$sample_id[clean_metadata$tissue == "Cord"]

# get the counts for each tissue type 
placenta_counts <- gene_counts[, placenta_samples]
cord_counts <- gene_counts[, cord_samples]

# get the metadata
placenta_metadata<- clean_metadata[clean_metadata$sample_id %in% placenta_samples,]
cord_metadata <- clean_metadata[clean_metadata$sample_id %in% cord_samples,]

# check to make sure we have the correct subsets
all(colnames(placenta_counts) == placenta_metadata$sample_id)
all(colnames(cord_counts) == cord_metadata$sample_id)
```

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
```{r}
# create the DESeq objects for DESeq
dds_placenta <- DESeqDataSetFromMatrix(
  countData = placenta_counts,
  colData = placenta_metadata,
  design = ~ condition
)

dds_cord <- DESeqDataSetFromMatrix(
  countData = cord_counts,
  colData = cord_metadata,
  design = ~ condition
)

# filter out low expressed genes
# keep genes with 10 or more genes in 3 or more samples
keep_placenta <- rowSums(counts(dds_placenta) >= 10) >=3
keep_cord <- rowSums(counts(dds_cord) >= 10) >=3

# filter out the low genes
dds_placenta <- dds_placenta[keep_placenta, ]
dds_cord <- dds_cord[keep_cord, ]

# Run DESeq2
dds_placenta <- DESeq(dds_placenta)
dds_cord <- DESeq(dds_cord)

```


```{r}
# separate results by condition for each tissue
results_placenta <- results(dds_placenta, contrast = c("condition", "GDM", "Control"))
results_cord <- results(dds_cord, contrast = c("condition", "GDM", "Control"))

# order by adjusted p-value
results_placenta <- results_placenta[order(results_placenta$padj), ]
results_cord <- results_cord[order(results_cord$padj), ]

head(results_placenta)
head(results_cord)
```

# Step 5: Differential Expression Results
```{r}
head(results_placenta, 20)
head(results_cord, 20)
```


```{r}
# count significant genes with p threshold of <0.05
sum(results_placenta$padj < 0.05, na.rm = TRUE)
sum(results_cord$padj < 0.05, na.rm = TRUE)


```

```{r}
# MA Plots
plotMA(results_placenta, ylim=c(-6,6), main ="Placenta: GDM vs Control")
plotMA(results_cord, ylim=c(-6,6), main= "Umbilical Cord: GDM vs Control")
```


```{r}
EnhancedVolcano(
  as.data.frame(results_placenta),
  lab = rownames(results_placenta),
  x = "log2FoldChange",
  y = "pvalue",
  title = "Placenta: GDM vs Control",
  axisLabSize = 10,
  pCutoff = 0.05,
  FCcutoff = 1,
  pointSize = 1,
  labSize = 2.0,
  col = c("grey30", "forestgreen", "royalblue", "red2"),
  legendPosition = "right",
  legendLabSize = 10,
  legendIconSize = 3,
  caption = NULL
)
```

```{r}
# PCA plots
plotPCA(vst(dds_placenta), intgroup = "condition")
```












